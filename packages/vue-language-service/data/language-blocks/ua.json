{
  "version": 1.1,
  "tags": [
    {
      "name": "template",
      "attributes": [
        {
          "name": "src",
          "description": {
            "kind": "markdown",
            "value": "\nЯкщо ви віддаєте перевагу розділенню ваших компонентів `*.vue` на кілька файлів, ви можете використовувати атрибут `src`, щоб імпортувати зовнішній файл для мовного блоку:\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\nПам’ятайте, що імпорт `src` дотримується тих самих правил вирішення шляху, що й запити модуля webpack, що означає:\n\n- Відносні шляхи повинні починатися з `./`\n- Ви можете імпортувати ресурси із залежностей npm:\n\n```vue\n<!-- імпорт файлу із встановленого npm-пакету \"todomvc-app-css\" -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` імпорт також працює з користувацькими блоками, напр.:\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
            }
          ]
        },
        {
          "name": "lang",
          "description": {
            "kind": "markdown",
            "value": "\nУ блоках можна оголосити мову пре-процесора за допомогою атрибуту `lang`. Найпоширенішим випадком є використання TypeScript для блоку `<script>`:\n\n```html\n<script lang=\"ts\">\n  // використовуємо TypeScript\n</script>\n```\n\n`lang` можна застосувати до будь-якого блоку - наприклад, ми можемо використовувати `<style>` з [Sass](https://sass-lang.com/) і `<template>` з [Pug](https:/ /pugjs.org/api/getting-started.html):\n\n```html\n<template lang=\"pug\">\np {{ msg }}\n</template>\n\n<style lang=\"scss\">\n  $primary-color: #333;\n  body {\n    color: $primary-color;\n  }\n</style>\n```\n\nЗауважте, що інтеграція з різними пре-процесорами може відрізнятися залежно від ланцюжка інструментів. Перегляньте відповідну документацію для прикладів:\n\n- [Vite](https://vitejs.dev/guide/features.html#css-pre-processors)\n- [Vue CLI](https://cli.vuejs.org/guide/css.html#pre-processors)\n- [webpack + vue-loader](https://vue-loader.vuejs.org/guide/pre-processors.html#using-pre-processors)\n"
          },
          "values": [
            {
              "name": "html"
            },
            {
              "name": "pug"
            }
          ],
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#pre-processors"
            }
          ]
        }
      ],
      "description": {
        "kind": "markdown",
        "value": "\n- Кожен файл `*.vue` може містити не більше одного блоку `<template>` верхнього рівня.\n\n- Вміст буде витягнуто та передано до `@vue/compiler-dom`, де попередньо скомпілюється в JavaScript функцію рендерингу і приєднано до компонента, що експортується, як його опція `render`.\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#template"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#template"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#template"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#template"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#template"
        }
      ]
    },
    {
      "name": "script",
      "attributes": [
        {
          "name": "src",
          "description": {
            "kind": "markdown",
            "value": "\nЯкщо ви віддаєте перевагу розділенню ваших компонентів `*.vue` на кілька файлів, ви можете використовувати атрибут `src`, щоб імпортувати зовнішній файл для мовного блоку:\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\nПам’ятайте, що імпорт `src` дотримується тих самих правил вирішення шляху, що й запити модуля webpack, що означає:\n\n- Відносні шляхи повинні починатися з `./`\n- Ви можете імпортувати ресурси із залежностей npm:\n\n```vue\n<!-- імпорт файлу із встановленого npm-пакету \"todomvc-app-css\" -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` імпорт також працює з користувацькими блоками, напр.:\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
            }
          ]
        },
        {
          "name": "lang",
          "description": {
            "kind": "markdown",
            "value": "\nУ блоках можна оголосити мову пре-процесора за допомогою атрибуту `lang`. Найпоширенішим випадком є використання TypeScript для блоку `<script>`:\n\n```html\n<script lang=\"ts\">\n  // використовуємо TypeScript\n</script>\n```\n\n`lang` можна застосувати до будь-якого блоку - наприклад, ми можемо використовувати `<style>` з [Sass](https://sass-lang.com/) і `<template>` з [Pug](https:/ /pugjs.org/api/getting-started.html):\n\n```html\n<template lang=\"pug\">\np {{ msg }}\n</template>\n\n<style lang=\"scss\">\n  $primary-color: #333;\n  body {\n    color: $primary-color;\n  }\n</style>\n```\n\nЗауважте, що інтеграція з різними пре-процесорами може відрізнятися залежно від ланцюжка інструментів. Перегляньте відповідну документацію для прикладів:\n\n- [Vite](https://vitejs.dev/guide/features.html#css-pre-processors)\n- [Vue CLI](https://cli.vuejs.org/guide/css.html#pre-processors)\n- [webpack + vue-loader](https://vue-loader.vuejs.org/guide/pre-processors.html#using-pre-processors)\n"
          },
          "values": [
            {
              "name": "ts"
            },
            {
              "name": "js"
            },
            {
              "name": "tsx"
            },
            {
              "name": "jsx"
            }
          ],
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#pre-processors"
            }
          ]
        },
        {
          "name": "setup",
          "valueSet": "v",
          "description": {
            "kind": "markdown",
            "value": "\n`<script setup>` is a compile-time syntactic sugar for using Composition API inside Single-File Components (SFCs). It is the recommended syntax if you are using both SFCs and Composition API. It provides a number of advantages over the normal `<script>` syntax:\n\n- More succinct code with less boilerplate\n- Ability to declare props and emitted events using pure TypeScript\n- Better runtime performance (the template is compiled into a render function in the same scope, without an intermediate proxy)\n- Better IDE type-inference performance (less work for the language server to extract types from code)\n\n## Basic Syntax \n\nTo opt-in to the syntax, add the `setup` attribute to the `<script>` block:\n\n```vue\n<script setup>\nconsole.log('hello script setup')\n</script>\n```\n\nThe code inside is compiled as the content of the component's `setup()` function. This means that unlike normal `<script>`, which only executes once when the component is first imported, code inside `<script setup>` will **execute every time an instance of the component is created**.\n\n### Top-level bindings are exposed to template \n\nWhen using `<script setup>`, any top-level bindings (including variables, function declarations, and imports) declared inside `<script setup>` are directly usable in the template:\n\n```vue\n<script setup>\n// variable\nconst msg = 'Hello!'\n\n// functions\nfunction log() {\n  console.log(msg)\n}\n</script>\n\n<template>\n  <button @click=\"log\">{{ msg }}</button>\n</template>\n```\n\nImports are exposed in the same fashion. This means you can directly use an imported helper function in template expressions without having to expose it via the `methods` option:\n\n```vue\n<script setup>\nimport { capitalize } from './helpers'\n</script>\n\n<template>\n  <div>{{ capitalize('hello') }}</div>\n</template>\n```\n\n## Reactivity \n\nReactive state needs to be explicitly created using [Reactivity APIs](./reactivity-core.html). Similar to values returned from a `setup()` function, refs are automatically unwrapped when referenced in templates:\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">{{ count }}</button>\n</template>\n```\n\n## Using Components \n\nValues in the scope of `<script setup>` can also be used directly as custom component tag names:\n\n```vue\n<script setup>\nimport MyComponent from './MyComponent.vue'\n</script>\n\n<template>\n  <MyComponent />\n</template>\n```\n\nThink of `MyComponent` as being referenced as a variable. If you have used JSX, the mental model is similar here. The kebab-case equivalent `<my-component>` also works in the template - however PascalCase component tags are strongly recommended for consistency. It also helps differentiating from native custom elements.\n\n### Dynamic Components \n\nSince components are referenced as variables instead of registered under string keys, we should use dynamic `:is` binding when using dynamic components inside `<script setup>`:\n\n```vue\n<script setup>\nimport Foo from './Foo.vue'\nimport Bar from './Bar.vue'\n</script>\n\n<template>\n  <component :is=\"Foo\" />\n  <component :is=\"someCondition ? Foo : Bar\" />\n</template>\n```\n\nNote how the components can be used as variables in a ternary expression.\n\n### Recursive Components \n\nAn SFC can implicitly refer to itself via its filename. E.g. a file named `FooBar.vue` can refer to itself as `<FooBar/>` in its template.\n\nNote this has lower priority than imported components. If you have a named import that conflicts with the component's inferred name, you can alias the import:\n\n```js\nimport { FooBar as FooBarChild } from './components'\n```\n\n### Namespaced Components \n\nYou can use component tags with dots like `<Foo.Bar>` to refer to components nested under object properties. This is useful when you import multiple components from a single file:\n\n```vue\n<script setup>\nimport * as Form from './form-components'\n</script>\n\n<template>\n  <Form.Input>\n    <Form.Label>label</Form.Label>\n  </Form.Input>\n</template>\n```\n\n## Using Custom Directives \n\nGlobally registered custom directives just work as normal. Local custom directives don't need to be explicitly registered with `<script setup>`, but they must follow the naming scheme `vNameOfDirective`:\n\n```vue\n<script setup>\nconst vMyDirective = {\n  beforeMount: (el) => {\n    // do something with the element\n  }\n}\n</script>\n<template>\n  <h1 v-my-directive>This is a Heading</h1>\n</template>\n```\n\nIf you're importing a directive from elsewhere, it can be renamed to fit the required naming scheme:\n\n```vue\n<script setup>\nimport { myDirective as vMyDirective } from './MyDirective.js'\n</script>\n```\n\n## defineProps() & defineEmits() \n\nTo declare options like `props` and `emits` with full type inference support, we can use the `defineProps` and `defineEmits` APIs, which are automatically available inside `<script setup>`:\n\n```vue\n<script setup>\nconst props = defineProps({\n  foo: String\n})\n\nconst emit = defineEmits(['change', 'delete'])\n// setup code\n</script>\n```\n\n- `defineProps` and `defineEmits` are **compiler macros** only usable inside `<script setup>`. They do not need to be imported, and are compiled away when `<script setup>` is processed.\n\n- `defineProps` accepts the same value as the `props` option, while `defineEmits` accepts the same value as the `emits` option.\n\n- `defineProps` and `defineEmits` provide proper type inference based on the options passed.\n\n- The options passed to `defineProps` and `defineEmits` will be hoisted out of setup into module scope. Therefore, the options cannot reference local variables declared in setup scope. Doing so will result in a compile error. However, it _can_ reference imported bindings since they are in the module scope as well.\n\nIf you are using TypeScript, it is also possible to [declare props and emits using pure type annotations](#typescript-only-features).\n\n## defineExpose() \n\nComponents using `<script setup>` are **closed by default** - i.e. the public instance of the component, which is retrieved via template refs or `$parent` chains, will **not** expose any of the bindings declared inside `<script setup>`.\n\nTo explicitly expose properties in a `<script setup>` component, use the `defineExpose` compiler macro:\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst a = 1\nconst b = ref(2)\n\ndefineExpose({\n  a,\n  b\n})\n</script>\n```\n\nWhen a parent gets an instance of this component via template refs, the retrieved instance will be of the shape `{ a: number, b: number }` (refs are automatically unwrapped just like on normal instances).\n\n## `useSlots()` & `useAttrs()` \n\nUsage of `slots` and `attrs` inside `<script setup>` should be relatively rare, since you can access them directly as `$slots` and `$attrs` in the template. In the rare case where you do need them, use the `useSlots` and `useAttrs` helpers respectively:\n\n```vue\n<script setup>\nimport { useSlots, useAttrs } from 'vue'\n\nconst slots = useSlots()\nconst attrs = useAttrs()\n</script>\n```\n\n`useSlots` and `useAttrs` are actual runtime functions that return the equivalent of `setupContext.slots` and `setupContext.attrs`. They can be used in normal composition API functions as well.\n\n## Usage alongside normal `<script>` \n\n`<script setup>` can be used alongside normal `<script>`. A normal `<script>` may be needed in cases where we need to:\n\n- Declare options that cannot be expressed in `<script setup>`, for example `inheritAttrs` or custom options enabled via plugins.\n- Declaring named exports.\n- Run side effects or create objects that should only execute once.\n\n```vue\n<script>\n// normal <script>, executed in module scope (only once)\nrunSideEffectOnce()\n\n// declare additional options\nexport default {\n  inheritAttrs: false,\n  customOptions: {}\n}\n</script>\n\n<script setup>\n// executed in setup() scope (for each instance)\n</script>\n```\n\nSupport for combining `<script setup>` and `<script>` in the same component is limited to the scenarios described above. Specifically:\n\n- Do **NOT** use a separate `<script>` section for options that can already be defined using `<script setup>`, such as `props` and `emits`.\n- Variables created inside `<script setup>` are not added as properties to the component instance, making them inaccessible from the Options API. Mixing APIs in this way is strongly discouraged.\n\nIf you find yourself in one of the scenarios that is not supported then you should consider switching to an explicit [`setup()`](https://ua.vuejs.org/api/composition-api-setup.html) function, instead of using `<script setup>`.\n\n## Top-level `await` \n\nTop-level `await` can be used inside `<script setup>`. The resulting code will be compiled as `async setup()`:\n\n```vue\n<script setup>\nconst post = await fetch(`/api/post/1`).then((r) => r.json())\n</script>\n```\n\nIn addition, the awaited expression will be automatically compiled in a format that preserves the current component instance context after the `await`.\n\n:::warning Note\n`async setup()` must be used in combination with `Suspense`, which is currently still an experimental feature. We plan to finalize and document it in a future release - but if you are curious now, you can refer to its [tests](https://github.com/vuejs/core/blob/main/packages/runtime-core/__tests__/components/Suspense.spec.ts) to see how it works.\n:::\n\n## TypeScript-only Features <sup class=\"vt-badge ts\" /> \n\n### Type-only props/emit declarations \n\nProps and emits can also be declared using pure-type syntax by passing a literal type argument to `defineProps` or `defineEmits`:\n\n```ts\nconst props = defineProps<{\n  foo: string\n  bar?: number\n}>()\n\nconst emit = defineEmits<{\n  (e: 'change', id: number): void\n  (e: 'update', value: string): void\n}>()\n```\n\n- `defineProps` or `defineEmits` can only use either runtime declaration OR type declaration. Using both at the same time will result in a compile error.\n\n- When using type declaration, the equivalent runtime declaration is automatically generated from static analysis to remove the need for double declaration and still ensure correct runtime behavior.\n\n  - In dev mode, the compiler will try to infer corresponding runtime validation from the types. For example here `foo: String` is inferred from the `foo: string` type. If the type is a reference to an imported type, the inferred result will be `foo: null` (equal to `any` type) since the compiler does not have information of external files.\n\n  - In prod mode, the compiler will generate the array format declaration to reduce bundle size (the props here will be compiled into `['foo', 'bar']`)\n\n  - The emitted code is still TypeScript with valid typing, which can be further processed by other tools.\n\n- As of now, the type declaration argument must be one of the following to ensure correct static analysis:\n\n  - A type literal\n  - A reference to an interface or a type literal in the same file\n\n  Currently complex types and type imports from other files are not supported. It is possible to support type imports in the future.\n\n### Default props values when using type declaration \n\nOne drawback of the type-only `defineProps` declaration is that it doesn't have a way to provide default values for the props. To resolve this problem, a `withDefaults` compiler macro is also provided:\n\n```ts\nexport interface Props {\n  msg?: string\n  labels?: string[]\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  msg: 'hello',\n  labels: () => ['one', 'two']\n})\n```\n\nThis will be compiled to equivalent runtime props `default` options. In addition, the `withDefaults` helper provides type checks for the default values, and ensures the returned `props` type has the optional flags removed for properties that do have default values declared.\n\n## Restrictions \n\nDue to the difference in module execution semantics, code inside `<script setup>` relies on the context of an SFC. When moved into external `.js` or `.ts` files, it may lead to confusion for both developers and tools. Therefore, **`<script setup>`** cannot be used with the `src` attribute.\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-script-setup.html"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-script-setup.html"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-script-setup.html"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-script-setup.html"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-script-setup.html"
            }
          ]
        },
        {
          "name": "generic"
        }
      ],
      "description": {
        "kind": "markdown",
        "value": "\n- Кожен файл `*.vue` може містити не більше одного блоку `<script>` (за винятком [`<script setup>`](https://ua.vuejs.org/api/sfc-script-setup.html)).\n\n- Сценарій виконується як ES модуль.\n\n- **Експорт за промовчанням** повинен бути об'єктом опцій компонента Vue, або звичайним об'єктом, або як значення, що повертається [defineComponent](https://ua.vuejs.org/api/general.html#definecomponent).\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#script"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#script"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#script"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#script"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#script"
        }
      ]
    },
    {
      "name": "script setup",
      "attributes": [
        {
          "name": "src",
          "description": {
            "kind": "markdown",
            "value": "\nЯкщо ви віддаєте перевагу розділенню ваших компонентів `*.vue` на кілька файлів, ви можете використовувати атрибут `src`, щоб імпортувати зовнішній файл для мовного блоку:\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\nПам’ятайте, що імпорт `src` дотримується тих самих правил вирішення шляху, що й запити модуля webpack, що означає:\n\n- Відносні шляхи повинні починатися з `./`\n- Ви можете імпортувати ресурси із залежностей npm:\n\n```vue\n<!-- імпорт файлу із встановленого npm-пакету \"todomvc-app-css\" -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` імпорт також працює з користувацькими блоками, напр.:\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
            }
          ]
        }
      ],
      "description": {
        "kind": "markdown",
        "value": "\n- Кожен файл `*.vue` може містити не більше одного блоку `<script setup>` (за винятком звичайного `<script>`).\n\n- Сценарій попередньо обробляється і використовується як функція компонента `setup()`, що означає, що вона виконуватиметься **для кожного екземпляра компонента**. Прив'язки верхнього рівня `<script setup>` автоматично оголошуються в шаблоні. Більш детальну інформацію можна знайти [на спеціальній сторінці документації `<script setup>`](https://ua.vuejs.org/api/sfc-script-setup.html)\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#script-setup"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#script-setup"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#script-setup"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#script-setup"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#script-setup"
        }
      ]
    },
    {
      "name": "style",
      "attributes": [
        {
          "name": "src",
          "description": {
            "kind": "markdown",
            "value": "\nЯкщо ви віддаєте перевагу розділенню ваших компонентів `*.vue` на кілька файлів, ви можете використовувати атрибут `src`, щоб імпортувати зовнішній файл для мовного блоку:\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\nПам’ятайте, що імпорт `src` дотримується тих самих правил вирішення шляху, що й запити модуля webpack, що означає:\n\n- Відносні шляхи повинні починатися з `./`\n- Ви можете імпортувати ресурси із залежностей npm:\n\n```vue\n<!-- імпорт файлу із встановленого npm-пакету \"todomvc-app-css\" -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` імпорт також працює з користувацькими блоками, напр.:\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
            }
          ]
        },
        {
          "name": "lang",
          "description": {
            "kind": "markdown",
            "value": "\nУ блоках можна оголосити мову пре-процесора за допомогою атрибуту `lang`. Найпоширенішим випадком є використання TypeScript для блоку `<script>`:\n\n```html\n<script lang=\"ts\">\n  // використовуємо TypeScript\n</script>\n```\n\n`lang` можна застосувати до будь-якого блоку - наприклад, ми можемо використовувати `<style>` з [Sass](https://sass-lang.com/) і `<template>` з [Pug](https:/ /pugjs.org/api/getting-started.html):\n\n```html\n<template lang=\"pug\">\np {{ msg }}\n</template>\n\n<style lang=\"scss\">\n  $primary-color: #333;\n  body {\n    color: $primary-color;\n  }\n</style>\n```\n\nЗауважте, що інтеграція з різними пре-процесорами може відрізнятися залежно від ланцюжка інструментів. Перегляньте відповідну документацію для прикладів:\n\n- [Vite](https://vitejs.dev/guide/features.html#css-pre-processors)\n- [Vue CLI](https://cli.vuejs.org/guide/css.html#pre-processors)\n- [webpack + vue-loader](https://vue-loader.vuejs.org/guide/pre-processors.html#using-pre-processors)\n"
          },
          "values": [
            {
              "name": "css"
            },
            {
              "name": "scss"
            },
            {
              "name": "less"
            },
            {
              "name": "stylus"
            },
            {
              "name": "postcss"
            },
            {
              "name": "sass"
            }
          ],
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#pre-processors"
            }
          ]
        },
        {
          "name": "scoped",
          "valueSet": "v",
          "description": {
            "kind": "markdown",
            "value": "\nWhen a `<style>` tag has the `scoped` attribute, its CSS will apply to elements of the current component only. This is similar to the style encapsulation found in Shadow DOM. It comes with some caveats, but doesn't require any polyfills. It is achieved by using PostCSS to transform the following:\n\n```vue\n<style scoped>\n.example {\n  color: red;\n}\n</style>\n\n<template>\n  <div class=\"example\">hi</div>\n</template>\n```\n\nInto the following:\n\n```vue\n<style>\n.example[data-v-f3f3eg9] {\n  color: red;\n}\n</style>\n\n<template>\n  <div class=\"example\" data-v-f3f3eg9>hi</div>\n</template>\n```\n\n### Child Component Root Elements \n\nWith `scoped`, the parent component's styles will not leak into child components. However, a child component's root node will be affected by both the parent's scoped CSS and the child's scoped CSS. This is by design so that the parent can style the child root element for layout purposes.\n\n### Deep Selectors \n\nIf you want a selector in `scoped` styles to be \"deep\", i.e. affecting child components, you can use the `:deep()` pseudo-class:\n\n```vue\n<style scoped>\n.a :deep(.b) {\n  /* ... */\n}\n</style>\n```\n\nThe above will be compiled into:\n\n```css\n.a[data-v-f3f3eg9] .b {\n  /* ... */\n}\n```\n\n:::tip\nDOM content created with `v-html` are not affected by scoped styles, but you can still style them using deep selectors.\n:::\n\n### Slotted Selectors \n\nBy default, scoped styles do not affect contents rendered by `<slot/>`, as they are considered to be owned by the parent component passing them in. To explicitly target slot content, use the `:slotted` pseudo-class:\n\n```vue\n<style scoped>\n:slotted(div) {\n  color: red;\n}\n</style>\n```\n\n### Global Selectors \n\nIf you want just one rule to apply globally, you can use the `:global` pseudo-class rather than creating another `<style>` (see below):\n\n```vue\n<style scoped>\n:global(.red) {\n  color: red;\n}\n</style>\n```\n\n### Mixing Local and Global Styles \n\nYou can also include both scoped and non-scoped styles in the same component:\n\n```vue\n<style>\n/* global styles */\n</style>\n\n<style scoped>\n/* local styles */\n</style>\n```\n\n### Scoped Style Tips \n\n- **Scoped styles do not eliminate the need for classes**. Due to the way browsers render various CSS selectors, `p { color: red }` will be many times slower when scoped (i.e. when combined with an attribute selector). If you use classes or ids instead, such as in `.example { color: red }`, then you virtually eliminate that performance hit.\n\n- **Be careful with descendant selectors in recursive components!** For a CSS rule with the selector `.a .b`, if the element that matches `.a` contains a recursive child component, then all `.b` in that child component will be matched by the rule.\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-css-features.html#scoped-css"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-css-features.html#scoped-css"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-css-features.html#scoped-css"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-css-features.html#scoped-css"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-css-features.html#scoped-css"
            }
          ]
        },
        {
          "name": "module",
          "valueSet": "v",
          "description": {
            "kind": "markdown",
            "value": "\nA `<style module>` tag is compiled as [CSS Modules](https://github.com/css-modules/css-modules) and exposes the resulting CSS classes to the component as an object under the key of `$style`:\n\n```vue\n<template>\n  <p :class=\"$style.red\">This should be red</p>\n</template>\n\n<style module>\n.red {\n  color: red;\n}\n</style>\n```\n\nThe resulting classes are hashed to avoid collision, achieving the same effect of scoping the CSS to the current component only.\n\nRefer to the [CSS Modules spec](https://github.com/css-modules/css-modules) for more details such as [global exceptions](https://github.com/css-modules/css-modules#exceptions) and [composition](https://github.com/css-modules/css-modules#composition).\n\n### Custom Inject Name \n\nYou can customize the property key of the injected classes object by giving the `module` attribute a value:\n\n```vue\n<template>\n  <p :class=\"classes.red\">red</p>\n</template>\n\n<style module=\"classes\">\n.red {\n  color: red;\n}\n</style>\n```\n\n### Usage with Composition API \n\nThe injected classes can be accessed in `setup()` and `<script setup>` via the `useCssModule` API. For `<style module>` blocks with custom injection names, `useCssModule` accepts the matching `module` attribute value as the first argument:\n\n```js\nimport { useCssModule } from 'vue'\n\n// inside setup() scope...\n// default, returns classes for <style module>\nuseCssModule()\n\n// named, returns classes for <style module=\"classes\">\nuseCssModule('classes')\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-css-features.html#css-modules"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-css-features.html#css-modules"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-css-features.html#css-modules"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-css-features.html#css-modules"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-css-features.html#css-modules"
            }
          ]
        }
      ],
      "description": {
        "kind": "markdown",
        "value": "\n- Один файл `*.vue` може містити кілька тегів `<style>`.\n\n- Тег `<style>` може мати атрибути `scoped` або `module` (додаткову інформацію див. у розділі [можливості стилів одно-файлового компонента](https://ua.vuejs.org/api/sfc-css-features.html), щоб допомогти інкапсулювати стилі в поточний компонент. В одному компоненті можна змішувати кілька тегів `<style>` з різними режимами інкапсуляції.\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#style"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#style"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#style"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#style"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#style"
        }
      ]
    },
    {
      "name": "Користувацькі блоки",
      "attributes": [
        {
          "name": "src",
          "description": {
            "kind": "markdown",
            "value": "\nЯкщо ви віддаєте перевагу розділенню ваших компонентів `*.vue` на кілька файлів, ви можете використовувати атрибут `src`, щоб імпортувати зовнішній файл для мовного блоку:\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\nПам’ятайте, що імпорт `src` дотримується тих самих правил вирішення шляху, що й запити модуля webpack, що означає:\n\n- Відносні шляхи повинні починатися з `./`\n- Ви можете імпортувати ресурси із залежностей npm:\n\n```vue\n<!-- імпорт файлу із встановленого npm-пакету \"todomvc-app-css\" -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` імпорт також працює з користувацькими блоками, напр.:\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
            }
          ]
        }
      ],
      "description": {
        "kind": "markdown",
        "value": "\nДодаткові користувацькі блоки можна включити у файл `*.vue` для будь-яких потреб конкретного проекту, наприклад, блок `<docs>`. Деякі реальні приклади спеціальних блоків включають:\n\n- [Gridsome: `<page-query>`](https://gridsome.org/docs/querying-data/)\n- [vite-plugin-vue-gql: `<gql>`](https://github.com/wheatjs/vite-plugin-vue-gql)\n- [vue-i18n: `<i18n>`](https://github.com/intlify/bundle-tools/tree/main/packages/vite-plugin-vue-i18n#i18n-custom-block)\n\nОбробка користувацьких блоків залежатиме від інструментів. Якщо ви хочете створити власні користувацькі інтеграції блоків, див. [відповідний розділ інструментів](https://ua.vuejs.org/guide/scaling-up/tooling.html#sfc-custom-block-integrations), щоб отримати докладнішу інформацію.\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#користувацькі-блоки"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#користувацькі-блоки"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#користувацькі-блоки"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#користувацькі-блоки"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#користувацькі-блоки"
        }
      ]
    }
  ],
  "globalAttributes": [
    {
      "name": "lang",
      "description": {
        "kind": "markdown",
        "value": "\nУ блоках можна оголосити мову пре-процесора за допомогою атрибуту `lang`. Найпоширенішим випадком є використання TypeScript для блоку `<script>`:\n\n```html\n<script lang=\"ts\">\n  // використовуємо TypeScript\n</script>\n```\n\n`lang` можна застосувати до будь-якого блоку - наприклад, ми можемо використовувати `<style>` з [Sass](https://sass-lang.com/) і `<template>` з [Pug](https:/ /pugjs.org/api/getting-started.html):\n\n```html\n<template lang=\"pug\">\np {{ msg }}\n</template>\n\n<style lang=\"scss\">\n  $primary-color: #333;\n  body {\n    color: $primary-color;\n  }\n</style>\n```\n\nЗауважте, що інтеграція з різними пре-процесорами може відрізнятися залежно від ланцюжка інструментів. Перегляньте відповідну документацію для прикладів:\n\n- [Vite](https://vitejs.dev/guide/features.html#css-pre-processors)\n- [Vue CLI](https://cli.vuejs.org/guide/css.html#pre-processors)\n- [webpack + vue-loader](https://vue-loader.vuejs.org/guide/pre-processors.html#using-pre-processors)\n"
      },
      "values": [],
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#pre-processors"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#pre-processors"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#pre-processors"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#pre-processors"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#pre-processors"
        }
      ]
    },
    {
      "name": "src",
      "description": {
        "kind": "markdown",
        "value": "\nЯкщо ви віддаєте перевагу розділенню ваших компонентів `*.vue` на кілька файлів, ви можете використовувати атрибут `src`, щоб імпортувати зовнішній файл для мовного блоку:\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\nПам’ятайте, що імпорт `src` дотримується тих самих правил вирішення шляху, що й запити модуля webpack, що означає:\n\n- Відносні шляхи повинні починатися з `./`\n- Ви можете імпортувати ресурси із залежностей npm:\n\n```vue\n<!-- імпорт файлу із встановленого npm-пакету \"todomvc-app-css\" -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` імпорт також працює з користувацькими блоками, напр.:\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
        }
      ]
    }
  ]
}