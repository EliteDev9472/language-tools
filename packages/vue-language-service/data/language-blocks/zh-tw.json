{
  "version": 1.1,
  "tags": [
    {
      "name": "template",
      "attributes": [
        {
          "name": "src",
          "description": {
            "kind": "markdown",
            "value": "\n如果你更喜歡將 `*.vue` 組件分散到多個文件中，可以爲一個語塊使用 `src` 這個 attribute 來導入一個外部文件：\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\n請注意 `src` 導入和 JS 模塊導入遵循相同的路徑解析規則，這意味着：\n\n- 相對路徑需要以 `./` 開頭\n- 你也可以從 npm 依賴中導入資源\n\n```vue\n<!-- 從所安裝的 \"todomvc-app-css\" npm 包中導入一個文件 -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` 導入對自定義語塊也同樣適用：\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
            }
          ]
        },
        {
          "name": "lang",
          "description": {
            "kind": "markdown",
            "value": "\n代碼塊可以使用 `lang` 這個 attribute 來聲明預處理器語言，最常見的用例就是在 `<script>` 中使用 TypeScript：\n\n```html\n<script lang=\"ts\">\n  // use TypeScript\n</script>\n```\n\n`lang` 在任意塊上都能使用，比如我們可以在 `<style>` 標籤中使用 [Sass](https://sass-lang.com/) 或是 `<template>` 中使用 [Pug](https://pugjs.org/api/getting-started.html)：\n\n```html\n<template lang=\"pug\">\np {{ msg }}\n</template>\n\n<style lang=\"scss\">\n  $primary-color: #333;\n  body {\n    color: $primary-color;\n  }\n</style>\n```\n\n注意對不同預處理器的集成會根據你所使用的工具鏈而有所不同，具體細節請查看相應的工具鏈文檔來確認：\n\n- [Vite](https://cn.vitejs.dev/guide/features.html#css-pre-processors)\n- [Vue CLI](https://cli.vuejs.org/zh/guide/css.html#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8)\n- [webpack + vue-loader](https://vue-loader.vuejs.org/zh/guide/pre-processors.html#%E4%BD%BF%E7%94%A8%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8)\n"
          },
          "values": [
            {
              "name": "html"
            },
            {
              "name": "pug"
            }
          ],
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#pre-processors"
            }
          ]
        }
      ],
      "description": {
        "kind": "markdown",
        "value": "\n- 每個 `*.vue` 文件最多可以包含一個頂層 `<template>` 塊。\n\n- 語塊包裹的內容將會被提取、傳遞給 `@vue/compiler-dom`，預編譯爲 JavaScript 渲染函數，並附在導出的組件上作爲其 `render` 選項。\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#template"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#template"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#template"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#template"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#template"
        }
      ]
    },
    {
      "name": "script",
      "attributes": [
        {
          "name": "src",
          "description": {
            "kind": "markdown",
            "value": "\n如果你更喜歡將 `*.vue` 組件分散到多個文件中，可以爲一個語塊使用 `src` 這個 attribute 來導入一個外部文件：\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\n請注意 `src` 導入和 JS 模塊導入遵循相同的路徑解析規則，這意味着：\n\n- 相對路徑需要以 `./` 開頭\n- 你也可以從 npm 依賴中導入資源\n\n```vue\n<!-- 從所安裝的 \"todomvc-app-css\" npm 包中導入一個文件 -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` 導入對自定義語塊也同樣適用：\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
            }
          ]
        },
        {
          "name": "lang",
          "description": {
            "kind": "markdown",
            "value": "\n代碼塊可以使用 `lang` 這個 attribute 來聲明預處理器語言，最常見的用例就是在 `<script>` 中使用 TypeScript：\n\n```html\n<script lang=\"ts\">\n  // use TypeScript\n</script>\n```\n\n`lang` 在任意塊上都能使用，比如我們可以在 `<style>` 標籤中使用 [Sass](https://sass-lang.com/) 或是 `<template>` 中使用 [Pug](https://pugjs.org/api/getting-started.html)：\n\n```html\n<template lang=\"pug\">\np {{ msg }}\n</template>\n\n<style lang=\"scss\">\n  $primary-color: #333;\n  body {\n    color: $primary-color;\n  }\n</style>\n```\n\n注意對不同預處理器的集成會根據你所使用的工具鏈而有所不同，具體細節請查看相應的工具鏈文檔來確認：\n\n- [Vite](https://cn.vitejs.dev/guide/features.html#css-pre-processors)\n- [Vue CLI](https://cli.vuejs.org/zh/guide/css.html#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8)\n- [webpack + vue-loader](https://vue-loader.vuejs.org/zh/guide/pre-processors.html#%E4%BD%BF%E7%94%A8%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8)\n"
          },
          "values": [
            {
              "name": "ts"
            },
            {
              "name": "js"
            },
            {
              "name": "tsx"
            },
            {
              "name": "jsx"
            }
          ],
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#pre-processors"
            }
          ]
        },
        {
          "name": "setup",
          "valueSet": "v",
          "description": {
            "kind": "markdown",
            "value": "\n`<script setup>` 是在單文件組件 (SFC) 中使用組合式 API 的編譯時語法糖。當同時使用 SFC 與組合式 API 時該語法是默認推薦。相比於普通的 `<script>` 語法，它具有更多優勢：\n\n- 更少的樣板內容，更簡潔的代碼。\n- 能夠使用純 TypeScript 聲明 props 和自定義事件。\n- 更好的運行時性能 (其模板會被編譯成同一作用域內的渲染函數，避免了渲染上下文代理對象)。\n- 更好的 IDE 類型推導性能 (減少了語言服務器從代碼中抽取類型的工作)。\n\n## 基本語法 \n\n要啓用該語法，需要在 `<script>` 代碼塊上添加 `setup` attribute：\n\n```vue\n<script setup>\nconsole.log('hello script setup')\n</script>\n```\n\n裏面的代碼會被編譯成組件 `setup()` 函數的內容。這意味着與普通的 `<script>` 只在組件被首次引入的時候執行一次不同，`<script setup>` 中的代碼會在**每次組件實例被創建的時候執行**。\n\n### 頂層的綁定會被暴露給模板 \n\n當使用 `<script setup>` 的時候，任何在 `<script setup>` 聲明的頂層的綁定 (包括變量，函數聲明，以及 import 導入的內容) 都能在模板中直接使用：\n\n```vue\n<script setup>\n// 變量\nconst msg = 'Hello!'\n\n// 函數\nfunction log() {\n  console.log(msg)\n}\n</script>\n\n<template>\n  <button @click=\"log\">{{ msg }}</button>\n</template>\n```\n\nimport 導入的內容也會以同樣的方式暴露。這意味着我們可以在模板表達式中直接使用導入的 helper 函數，而不需要通過 `methods` 選項來暴露它：\n\n```vue\n<script setup>\nimport { capitalize } from './helpers'\n</script>\n\n<template>\n  <div>{{ capitalize('hello') }}</div>\n</template>\n```\n\n## 響應式 \n\n響應式狀態需要明確使用[響應式 API](https://cn.vuejs.org/api/reactivity-core.html) 來創建。和 `setup()` 函數的返回值一樣，ref 在模板中使用的時候會自動解包：\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">{{ count }}</button>\n</template>\n```\n\n## 使用組件 \n\n`<script setup>` 範圍裏的值也能被直接作爲自定義組件的標籤名使用：\n\n```vue\n<script setup>\nimport MyComponent from './MyComponent.vue'\n</script>\n\n<template>\n  <MyComponent />\n</template>\n```\n\n這裏 `MyComponent` 應當被理解爲像是在引用一個變量。如果你使用過 JSX，此處的心智模型是類似的。其 kebab-case 格式的 `<my-component>` 同樣能在模板中使用——不過，我們強烈建議使用 PascalCase 格式以保持一致性。同時這也有助於區分原生的自定義元素。\n\n### 動態組件 \n\n由於組件是通過變量引用而不是基於字符串組件名註冊的，在 `<script setup>` 中要使用動態組件的時候，應該使用動態的 `:is` 來綁定：\n\n```vue\n<script setup>\nimport Foo from './Foo.vue'\nimport Bar from './Bar.vue'\n</script>\n\n<template>\n  <component :is=\"Foo\" />\n  <component :is=\"someCondition ? Foo : Bar\" />\n</template>\n```\n\n請注意組件是如何在三元表達式中被當做變量使用的。\n\n### 遞歸組件 \n\n一個單文件組件可以通過它的文件名被其自己所引用。例如：名爲 `FooBar.vue` 的組件可以在其模板中用 `<FooBar/>` 引用它自己。\n\n請注意這種方式相比於導入的組件優先級更低。如果有具名的導入和組件自身推導的名字衝突了，可以爲導入的組件添加別名：\n\n```js\nimport { FooBar as FooBarChild } from './components'\n```\n\n### 命名空間組件 \n\n可以使用帶 `.` 的組件標籤，例如 `<Foo.Bar>` 來引用嵌套在對象屬性中的組件。這在需要從單個文件中導入多個組件的時候非常有用：\n\n```vue\n<script setup>\nimport * as Form from './form-components'\n</script>\n\n<template>\n  <Form.Input>\n    <Form.Label>label</Form.Label>\n  </Form.Input>\n</template>\n```\n\n## 使用自定義指令 \n\n全局註冊的自定義指令將正常工作。本地的自定義指令在 `<script setup>` 中不需要顯式註冊，但他們必須遵循 `vNameOfDirective` 這樣的命名規範：\n\n```vue\n<script setup>\nconst vMyDirective = {\n  beforeMount: (el) => {\n    // 在元素上做些操作\n  }\n}\n</script>\n<template>\n  <h1 v-my-directive>This is a Heading</h1>\n</template>\n```\n\n如果指令是從別處導入的，可以通過重命名來使其符合命名規範：\n\n```vue\n<script setup>\nimport { myDirective as vMyDirective } from './MyDirective.js'\n</script>\n```\n\n## defineProps() 和 defineEmits() \n\n爲了在聲明 `props` 和 `emits` 選項時獲得完整的類型推導支持，我們可以使用 `defineProps` 和 `defineEmits` API，它們將自動地在 `<script setup>` 中可用：\n\n```vue\n<script setup>\nconst props = defineProps({\n  foo: String\n})\n\nconst emit = defineEmits(['change', 'delete'])\n// setup 代碼\n</script>\n```\n\n- `defineProps` 和 `defineEmits` 都是隻能在 `<script setup>` 中使用的**編譯器宏**。他們不需要導入，且會隨着 `<script setup>` 的處理過程一同被編譯掉。\n\n- `defineProps` 接收與 `props` 選項相同的值，`defineEmits` 接收與 `emits` 選項相同的值。\n\n- `defineProps` 和 `defineEmits` 在選項傳入後，會提供恰當的類型推導。\n\n- 傳入到 `defineProps` 和 `defineEmits` 的選項會從 setup 中提升到模塊的作用域。因此，傳入的選項不能引用在 setup 作用域中聲明的局部變量。這樣做會引起編譯錯誤。但是，它*可以*引用導入的綁定，因爲它們也在模塊作用域內。\n\n如果使用了 TypeScript，[使用純類型聲明來聲明 prop 和 emit](#typescript-only-features) 也是可以的。\n\n## defineExpose() \n\n使用 `<script setup>` 的組件是**默認關閉**的——即通過模板引用或者 `$parent` 鏈獲取到的組件的公開實例，**不會**暴露任何在 `<script setup>` 中聲明的綁定。\n\n可以通過 `defineExpose` 編譯器宏來顯式指定在 `<script setup>` 組件中要暴露出去的屬性：\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst a = 1\nconst b = ref(2)\n\ndefineExpose({\n  a,\n  b\n})\n</script>\n```\n\n當父組件通過模板引用的方式獲取到當前組件的實例，獲取到的實例會像這樣 `{ a: number, b: number }` (ref 會和在普通實例中一樣被自動解包)\n\n## `useSlots()` 和 `useAttrs()` \n\n在 `<script setup>` 使用 `slots` 和 `attrs` 的情況應該是相對來說較爲罕見的，因爲可以在模板中直接通過 `$slots` 和 `$attrs` 來訪問它們。在你的確需要使用它們的罕見場景中，可以分別用 `useSlots` 和 `useAttrs` 兩個輔助函數：\n\n```vue\n<script setup>\nimport { useSlots, useAttrs } from 'vue'\n\nconst slots = useSlots()\nconst attrs = useAttrs()\n</script>\n```\n\n`useSlots` 和 `useAttrs` 是真實的運行時函數，它的返回與 `setupContext.slots` 和 `setupContext.attrs` 等價。它們同樣也能在普通的組合式 API 中使用。\n\n## 與普通的 `<script>` 一起使用 \n\n`<script setup>` 可以和普通的 `<script>` 一起使用。普通的 `<script>` 在有這些需要的情況下或許會被使用到：\n\n- 聲明無法在 `<script setup>` 中聲明的選項，例如 `inheritAttrs` 或插件的自定義選項。\n- 聲明模塊的具名導出 (named exports)。\n- 運行只需要在模塊作用域執行一次的副作用，或是創建單例對象。\n\n```vue\n<script>\n// 普通 <script>, 在模塊作用域下執行 (僅一次)\nrunSideEffectOnce()\n\n// 聲明額外的選項\nexport default {\n  inheritAttrs: false,\n  customOptions: {}\n}\n</script>\n\n<script setup>\n// 在 setup() 作用域中執行 (對每個實例皆如此)\n</script>\n```\n\n在同一組件中將 `<script setup>` 與 `<script>` 結合使用的支持僅限於上述情況。具體來說：\n\n- **不要**爲已經可以用 `<script setup>` 定義的選項使用單獨的 `<script>` 部分，如 `props` 和 `emits`。\n- 在 `<script setup>` 中創建的變量不會作爲屬性添加到組件實例中，這使得它們無法從選項式 API 中訪問。我們強烈反對以這種方式混合 API。\n\n如果你發現自己處於以上任一不被支持的場景中，那麼你應該考慮切換到一個顯式的 [`setup()`](https://cn.vuejs.org/api/composition-api-setup.html) 函數，而不是使用 `<script setup>`。\n\n## 頂層 `await` \n\n`<script setup>` 中可以使用頂層 `await`。結果代碼會被編譯成 `async setup()`：\n\n```vue\n<script setup>\nconst post = await fetch(`/api/post/1`).then((r) => r.json())\n</script>\n```\n\n另外，await 的表達式會自動編譯成在 `await` 之後保留當前組件實例上下文的格式。\n\n:::warning 注意\n`async setup()` 必須與 [`Suspense` 內置組件](https://cn.vuejs.org/guide/built-ins/suspense.html)組合使用，`Suspense` 目前還是處於實驗階段的特性，會在將來的版本中穩定。\n:::\n\n## 針對 TypeScript 的功能 \n\n### 針對類型的 props/emit 聲明 \n\nprops 和 emit 都可以通過給 `defineProps` 和 `defineEmits` 傳遞純類型參數的方式來聲明：\n\n```ts\nconst props = defineProps<{\n  foo: string\n  bar?: number\n}>()\n\nconst emit = defineEmits<{\n  (e: 'change', id: number): void\n  (e: 'update', value: string): void\n}>()\n```\n\n- `defineProps` 或 `defineEmits` 要麼使用運行時聲明，要麼使用類型聲明。同時使用兩種聲明方式會導致編譯報錯。\n\n- 使用類型聲明的時候，靜態分析會自動生成等效的運行時聲明，從而在避免雙重聲明的前提下確保正確的運行時行爲。\n\n  - 在開發模式下，編譯器會試着從類型來推導對應的運行時驗證。例如這裏從 `foo: string` 類型中推斷出 `foo: String`。如果類型是對導入類型的引用，這裏的推導結果會是 `foo: null` (與 `any` 類型相等)，因爲編譯器沒有外部文件的信息。\n\n  - 在生產模式下，編譯器會生成數組格式的聲明來減少打包體積 (這裏的 props 會被編譯成 `['foo', 'bar']`)。\n\n  - 生成的代碼仍然是有着合法類型的 TypeScript 代碼，它可以在後續的流程中被其他工具處理。\n\n- 截至目前，類型聲明參數必須是以下內容之一，以確保正確的靜態分析：\n\n  - 類型字面量\n  - 在同一文件中的接口或類型字面量的引用\n\n  現在還不支持複雜的類型和從其他文件進行類型導入，但我們有計劃在將來支持。\n\n### 使用類型聲明時的默認 props 值 \n\n針對類型的 `defineProps` 聲明的不足之處在於，它沒有可以給 props 提供默認值的方式。爲了解決這個問題，我們還提供了 `withDefaults` 編譯器宏：\n\n```ts\nexport interface Props {\n  msg?: string\n  labels?: string[]\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  msg: 'hello',\n  labels: () => ['one', 'two']\n})\n```\n\n上面代碼會被編譯爲等價的運行時 props 的 `default` 選項。此外，`withDefaults` 輔助函數提供了對默認值的類型檢查，並確保返回的 `props` 的類型刪除了已聲明默認值的屬性的可選標誌。\n\n## 限制 \n\n由於模塊執行語義的差異，`<script setup>` 中的代碼依賴單文件組件的上下文。當將其移動到外部的 `.js` 或者 `.ts` 文件中的時候，對於開發者和工具來說都會感到混亂。因此，**`<script setup>`** 不能和 `src` attribute 一起使用。\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-script-setup.html"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-script-setup.html"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-script-setup.html"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-script-setup.html"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-script-setup.html"
            }
          ]
        },
        {
          "name": "generic"
        }
      ],
      "description": {
        "kind": "markdown",
        "value": "\n- 每個 `*.vue` 文件最多可以包含一個 `<script>` 塊。(使用 [`<script setup>`](https://cn.vuejs.org/api/sfc-script-setup.html) 的情況除外)\n\n- 這個腳本代碼塊將作爲 ES 模塊執行。\n\n- **默認導出**應該是 Vue 的組件選項對象，可以是一個對象字面量或是 [defineComponent](https://cn.vuejs.org/api/general.html#definecomponent) 函數的返回值。\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#script"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#script"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#script"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#script"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#script"
        }
      ]
    },
    {
      "name": "script setup",
      "attributes": [
        {
          "name": "src",
          "description": {
            "kind": "markdown",
            "value": "\n如果你更喜歡將 `*.vue` 組件分散到多個文件中，可以爲一個語塊使用 `src` 這個 attribute 來導入一個外部文件：\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\n請注意 `src` 導入和 JS 模塊導入遵循相同的路徑解析規則，這意味着：\n\n- 相對路徑需要以 `./` 開頭\n- 你也可以從 npm 依賴中導入資源\n\n```vue\n<!-- 從所安裝的 \"todomvc-app-css\" npm 包中導入一個文件 -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` 導入對自定義語塊也同樣適用：\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
            }
          ]
        }
      ],
      "description": {
        "kind": "markdown",
        "value": "\n- 每個 `*.vue` 文件最多可以包含一個 `<script setup>`。(不包括一般的 `<script>`)\n\n- 這個腳本塊將被預處理爲組件的 `setup()` 函數，這意味着它將**爲每一個組件實例**都執行。`<script setup>` 中的頂層綁定都將自動暴露給模板。要了解更多細節，請看 [`<script setup>` 的專門文檔](https://cn.vuejs.org/api/sfc-script-setup.html)。\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#script-setup"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#script-setup"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#script-setup"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#script-setup"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#script-setup"
        }
      ]
    },
    {
      "name": "style",
      "attributes": [
        {
          "name": "src",
          "description": {
            "kind": "markdown",
            "value": "\n如果你更喜歡將 `*.vue` 組件分散到多個文件中，可以爲一個語塊使用 `src` 這個 attribute 來導入一個外部文件：\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\n請注意 `src` 導入和 JS 模塊導入遵循相同的路徑解析規則，這意味着：\n\n- 相對路徑需要以 `./` 開頭\n- 你也可以從 npm 依賴中導入資源\n\n```vue\n<!-- 從所安裝的 \"todomvc-app-css\" npm 包中導入一個文件 -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` 導入對自定義語塊也同樣適用：\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
            }
          ]
        },
        {
          "name": "lang",
          "description": {
            "kind": "markdown",
            "value": "\n代碼塊可以使用 `lang` 這個 attribute 來聲明預處理器語言，最常見的用例就是在 `<script>` 中使用 TypeScript：\n\n```html\n<script lang=\"ts\">\n  // use TypeScript\n</script>\n```\n\n`lang` 在任意塊上都能使用，比如我們可以在 `<style>` 標籤中使用 [Sass](https://sass-lang.com/) 或是 `<template>` 中使用 [Pug](https://pugjs.org/api/getting-started.html)：\n\n```html\n<template lang=\"pug\">\np {{ msg }}\n</template>\n\n<style lang=\"scss\">\n  $primary-color: #333;\n  body {\n    color: $primary-color;\n  }\n</style>\n```\n\n注意對不同預處理器的集成會根據你所使用的工具鏈而有所不同，具體細節請查看相應的工具鏈文檔來確認：\n\n- [Vite](https://cn.vitejs.dev/guide/features.html#css-pre-processors)\n- [Vue CLI](https://cli.vuejs.org/zh/guide/css.html#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8)\n- [webpack + vue-loader](https://vue-loader.vuejs.org/zh/guide/pre-processors.html#%E4%BD%BF%E7%94%A8%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8)\n"
          },
          "values": [
            {
              "name": "css"
            },
            {
              "name": "scss"
            },
            {
              "name": "less"
            },
            {
              "name": "stylus"
            },
            {
              "name": "postcss"
            },
            {
              "name": "sass"
            }
          ],
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#pre-processors"
            }
          ]
        },
        {
          "name": "scoped",
          "valueSet": "v",
          "description": {
            "kind": "markdown",
            "value": "\n當 `<style>` 標籤帶有 `scoped` attribute 的時候，它的 CSS 只會影響當前組件的元素，和 Shadow DOM 中的樣式封裝類似。使用時有一些注意事項，不過好處是不需要任何的 polyfill。它的實現方式是通過 PostCSS 將以下內容：\n\n```vue\n<style scoped>\n.example {\n  color: red;\n}\n</style>\n\n<template>\n  <div class=\"example\">hi</div>\n</template>\n```\n\n轉換爲：\n\n```vue\n<style>\n.example[data-v-f3f3eg9] {\n  color: red;\n}\n</style>\n\n<template>\n  <div class=\"example\" data-v-f3f3eg9>hi</div>\n</template>\n```\n\n### 子組件的根元素 \n\n使用 `scoped` 後，父組件的樣式將不會滲透到子組件中。不過，子組件的根節點會同時被父組件的作用域樣式和子組件的作用域樣式影響。這樣設計是爲了讓父組件可以從佈局的角度出發，調整其子組件根元素的樣式。\n\n### 深度選擇器 \n\n處於 `scoped` 樣式中的選擇器如果想要做更“深度”的選擇，也即：影響到子組件，可以使用 `:deep()` 這個僞類：\n\n```vue\n<style scoped>\n.a :deep(.b) {\n  /* ... */\n}\n</style>\n```\n\n上面的代碼會被編譯成：\n\n```css\n.a[data-v-f3f3eg9] .b {\n  /* ... */\n}\n```\n\n:::tip\n通過 `v-html` 創建的 DOM 內容不會被作用域樣式影響，但你仍然可以使用深度選擇器來設置其樣式。\n:::\n\n### 插槽選擇器 \n\n默認情況下，作用域樣式不會影響到 `<slot/>` 渲染出來的內容，因爲它們被認爲是父組件所持有並傳遞進來的。使用 `:slotted` 僞類以明確地將插槽內容作爲選擇器的目標：\n\n```vue\n<style scoped>\n:slotted(div) {\n  color: red;\n}\n</style>\n```\n\n### 全局選擇器 \n\n如果想讓其中一個樣式規則應用到全局，比起另外創建一個 `<style>`，可以使用 `:global` 僞類來實現 (看下面的代碼)：\n\n```vue\n<style scoped>\n:global(.red) {\n  color: red;\n}\n</style>\n```\n\n### 混合使用局部與全局樣式 \n\n你也可以在同一個組件中同時包含作用域樣式和非作用域樣式：\n\n```vue\n<style>\n/* 全局樣式 */\n</style>\n\n<style scoped>\n/* 局部樣式 */\n</style>\n```\n\n### 作用域樣式須知 \n\n- **作用域樣式並沒有消除對 class 的需求**。由於瀏覽器渲染各種各樣 CSS 選擇器的方式，`p { color: red }` 結合作用域樣式使用時 (即當與 attribute 選擇器組合的時候) 會慢很多倍。如果你使用 class 或者 id 來替代，例如 `.example { color: red }`，那你幾乎就可以避免性能的損失。\n\n- **小心遞歸組件中的後代選擇器**！對於一個使用了 `.a .b` 選擇器的樣式規則來說，如果匹配到 `.a` 的元素包含了一個遞歸的子組件，那麼所有的在那個子組件中的 `.b` 都會匹配到這條樣式規則。\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-css-features.html#scoped-css"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-css-features.html#scoped-css"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-css-features.html#scoped-css"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-css-features.html#scoped-css"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-css-features.html#scoped-css"
            }
          ]
        },
        {
          "name": "module",
          "valueSet": "v",
          "description": {
            "kind": "markdown",
            "value": "\n一個 `<style module>` 標籤會被編譯爲 [CSS Modules](https://github.com/css-modules/css-modules) 並且將生成的 CSS class 作爲 `$style` 對象暴露給組件：\n\n```vue\n<template>\n  <p :class=\"$style.red\">This should be red</p>\n</template>\n\n<style module>\n.red {\n  color: red;\n}\n</style>\n```\n\n得出的 class 將被哈希化以避免衝突，實現了同樣的將 CSS 僅作用於當前組件的效果。\n\n參考 [CSS Modules spec](https://github.com/css-modules/css-modules) 以查看更多詳情，例如 [global exceptions](https://github.com/css-modules/css-modules#exceptions) 和 [composition](https://github.com/css-modules/css-modules#composition)。\n\n### 自定義注入名稱 \n\n你可以通過給 `module` attribute 一個值來自定義注入 class 對象的屬性名：\n\n```vue\n<template>\n  <p :class=\"classes.red\">red</p>\n</template>\n\n<style module=\"classes\">\n.red {\n  color: red;\n}\n</style>\n```\n\n### 與組合式 API 一同使用 \n\n可以通過 `useCssModule` API 在 `setup()` 和 `<script setup>` 中訪問注入的 class。對於使用了自定義注入名稱的 `<style module>` 塊，`useCssModule` 接收一個匹配的 `module` attribute 值作爲第一個參數：\n\n```js\nimport { useCssModule } from 'vue'\n\n// 在 setup() 作用域中...\n// 默認情況下, 返回 <style module> 的 class\nuseCssModule()\n\n// 具名情況下, 返回 <style module=\"classes\"> 的 class\nuseCssModule('classes')\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-css-features.html#css-modules"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-css-features.html#css-modules"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-css-features.html#css-modules"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-css-features.html#css-modules"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-css-features.html#css-modules"
            }
          ]
        }
      ],
      "description": {
        "kind": "markdown",
        "value": "\n- 每個 `*.vue` 文件可以包含多個 `<style>` 標籤。\n\n- 一個 `<style>` 標籤可以使用 `scoped` 或 `module` attribute (查看 [SFC 樣式功能](https://cn.vuejs.org/api/sfc-css-features.html)瞭解更多細節) 來幫助封裝當前組件的樣式。使用了不同封裝模式的多個 `<style>` 標籤可以被混合入同一個組件。\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#style"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#style"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#style"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#style"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#style"
        }
      ]
    },
    {
      "name": "自定義塊",
      "attributes": [
        {
          "name": "src",
          "description": {
            "kind": "markdown",
            "value": "\n如果你更喜歡將 `*.vue` 組件分散到多個文件中，可以爲一個語塊使用 `src` 這個 attribute 來導入一個外部文件：\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\n請注意 `src` 導入和 JS 模塊導入遵循相同的路徑解析規則，這意味着：\n\n- 相對路徑需要以 `./` 開頭\n- 你也可以從 npm 依賴中導入資源\n\n```vue\n<!-- 從所安裝的 \"todomvc-app-css\" npm 包中導入一個文件 -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` 導入對自定義語塊也同樣適用：\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
            }
          ]
        }
      ],
      "description": {
        "kind": "markdown",
        "value": "\n在一個 `*.vue` 文件中可以爲任何項目特定需求使用額外的自定義塊。舉例來說，一個用作寫文檔的 `<docs>` 塊。這裏是一些自定義塊的真實用例：\n\n- [Gridsome：`<page-query>`](https://gridsome.org/docs/querying-data/)\n- [vite-plugin-vue-gql：`<gql>`](https://github.com/wheatjs/vite-plugin-vue-gql)\n- [vue-i18n：`<i18n>`](https://github.com/intlify/bundle-tools/tree/main/packages/vite-plugin-vue-i18n#i18n-custom-block)\n\n自定義塊的處理需要依賴工具鏈。如果你想要在構建中集成你的自定義語塊，請參見[相關工具鏈指南](https://cn.vuejs.org/guide/scaling-up/tooling.html#sfc-custom-block-integrations)獲取更多細節。\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#自定義塊"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#自定義塊"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#自定義塊"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#自定義塊"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#自定義塊"
        }
      ]
    }
  ],
  "globalAttributes": [
    {
      "name": "lang",
      "description": {
        "kind": "markdown",
        "value": "\n代碼塊可以使用 `lang` 這個 attribute 來聲明預處理器語言，最常見的用例就是在 `<script>` 中使用 TypeScript：\n\n```html\n<script lang=\"ts\">\n  // use TypeScript\n</script>\n```\n\n`lang` 在任意塊上都能使用，比如我們可以在 `<style>` 標籤中使用 [Sass](https://sass-lang.com/) 或是 `<template>` 中使用 [Pug](https://pugjs.org/api/getting-started.html)：\n\n```html\n<template lang=\"pug\">\np {{ msg }}\n</template>\n\n<style lang=\"scss\">\n  $primary-color: #333;\n  body {\n    color: $primary-color;\n  }\n</style>\n```\n\n注意對不同預處理器的集成會根據你所使用的工具鏈而有所不同，具體細節請查看相應的工具鏈文檔來確認：\n\n- [Vite](https://cn.vitejs.dev/guide/features.html#css-pre-processors)\n- [Vue CLI](https://cli.vuejs.org/zh/guide/css.html#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8)\n- [webpack + vue-loader](https://vue-loader.vuejs.org/zh/guide/pre-processors.html#%E4%BD%BF%E7%94%A8%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8)\n"
      },
      "values": [],
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#pre-processors"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#pre-processors"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#pre-processors"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#pre-processors"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#pre-processors"
        }
      ]
    },
    {
      "name": "src",
      "description": {
        "kind": "markdown",
        "value": "\n如果你更喜歡將 `*.vue` 組件分散到多個文件中，可以爲一個語塊使用 `src` 這個 attribute 來導入一個外部文件：\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\n請注意 `src` 導入和 JS 模塊導入遵循相同的路徑解析規則，這意味着：\n\n- 相對路徑需要以 `./` 開頭\n- 你也可以從 npm 依賴中導入資源\n\n```vue\n<!-- 從所安裝的 \"todomvc-app-css\" npm 包中導入一個文件 -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` 導入對自定義語塊也同樣適用：\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
        }
      ]
    }
  ]
}