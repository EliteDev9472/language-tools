{
  "version": 1.1,
  "tags": [
    {
      "name": "template",
      "attributes": [
        {
          "name": "src",
          "description": {
            "kind": "markdown",
            "value": "\nIf you prefer splitting up your `*.vue` components into multiple files, you can use the `src` attribute to import an external file for a language block:\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\nBeware that `src` imports follow the same path resolution rules as webpack module requests, which means:\n\n- Relative paths need to start with `./`\n- You can import resources from npm dependencies:\n\n```vue\n<!-- import a file from the installed \"todomvc-app-css\" npm package -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` imports also work with custom blocks, e.g.:\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
            }
          ]
        },
        {
          "name": "lang",
          "description": {
            "kind": "markdown",
            "value": "\nBlocks can declare pre-processor languages using the `lang` attribute. The most common case is using TypeScript for the `<script>` block:\n\n```html\n<script lang=\"ts\">\n  // use TypeScript\n</script>\n```\n\n`lang` can be applied to any block - for example we can use `<style>` with [Sass](https://sass-lang.com/) and `<template>` with [Pug](https://pugjs.org/api/getting-started.html):\n\n```html\n<template lang=\"pug\">\np {{ msg }}\n</template>\n\n<style lang=\"scss\">\n  $primary-color: #333;\n  body {\n    color: $primary-color;\n  }\n</style>\n```\n\nNote that integration with various pre-processors may differ by toolchain. Check out the respective documentation for examples:\n\n- [Vite](https://vitejs.dev/guide/features.html#css-pre-processors)\n- [Vue CLI](https://cli.vuejs.org/guide/css.html#pre-processors)\n- [webpack + vue-loader](https://vue-loader.vuejs.org/guide/pre-processors.html#using-pre-processors)\n"
          },
          "values": [
            {
              "name": "html"
            },
            {
              "name": "pug"
            }
          ],
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#pre-processors"
            }
          ]
        }
      ],
      "description": {
        "kind": "markdown",
        "value": "\n- Each `*.vue` file can contain at most one top-level `<template>` block at a time.\n\n- Contents will be extracted and passed on to `@vue/compiler-dom`, pre-compiled into JavaScript render functions, and attached to the exported component as its `render` option.\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#template"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#template"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#template"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#template"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#template"
        }
      ]
    },
    {
      "name": "script",
      "attributes": [
        {
          "name": "src",
          "description": {
            "kind": "markdown",
            "value": "\nIf you prefer splitting up your `*.vue` components into multiple files, you can use the `src` attribute to import an external file for a language block:\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\nBeware that `src` imports follow the same path resolution rules as webpack module requests, which means:\n\n- Relative paths need to start with `./`\n- You can import resources from npm dependencies:\n\n```vue\n<!-- import a file from the installed \"todomvc-app-css\" npm package -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` imports also work with custom blocks, e.g.:\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
            }
          ]
        },
        {
          "name": "lang",
          "description": {
            "kind": "markdown",
            "value": "\nBlocks can declare pre-processor languages using the `lang` attribute. The most common case is using TypeScript for the `<script>` block:\n\n```html\n<script lang=\"ts\">\n  // use TypeScript\n</script>\n```\n\n`lang` can be applied to any block - for example we can use `<style>` with [Sass](https://sass-lang.com/) and `<template>` with [Pug](https://pugjs.org/api/getting-started.html):\n\n```html\n<template lang=\"pug\">\np {{ msg }}\n</template>\n\n<style lang=\"scss\">\n  $primary-color: #333;\n  body {\n    color: $primary-color;\n  }\n</style>\n```\n\nNote that integration with various pre-processors may differ by toolchain. Check out the respective documentation for examples:\n\n- [Vite](https://vitejs.dev/guide/features.html#css-pre-processors)\n- [Vue CLI](https://cli.vuejs.org/guide/css.html#pre-processors)\n- [webpack + vue-loader](https://vue-loader.vuejs.org/guide/pre-processors.html#using-pre-processors)\n"
          },
          "values": [
            {
              "name": "ts"
            },
            {
              "name": "js"
            },
            {
              "name": "tsx"
            },
            {
              "name": "jsx"
            }
          ],
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#pre-processors"
            }
          ]
        },
        {
          "name": "setup",
          "valueSet": "v",
          "description": {
            "kind": "markdown",
            "value": "\n`<script setup>` is a compile-time syntactic sugar for using Composition API inside Single-File Components (SFCs). It is the recommended syntax if you are using both SFCs and Composition API. It provides a number of advantages over the normal `<script>` syntax:\n\n- More succinct code with less boilerplate\n- Ability to declare props and emitted events using pure TypeScript\n- Better runtime performance (the template is compiled into a render function in the same scope, without an intermediate proxy)\n- Better IDE type-inference performance (less work for the language server to extract types from code)\n\n## Basic Syntax \n\nTo opt-in to the syntax, add the `setup` attribute to the `<script>` block:\n\n```vue\n<script setup>\nconsole.log('hello script setup')\n</script>\n```\n\nThe code inside is compiled as the content of the component's `setup()` function. This means that unlike normal `<script>`, which only executes once when the component is first imported, code inside `<script setup>` will **execute every time an instance of the component is created**.\n\n### Top-level bindings are exposed to template \n\nWhen using `<script setup>`, any top-level bindings (including variables, function declarations, and imports) declared inside `<script setup>` are directly usable in the template:\n\n```vue\n<script setup>\n// variable\nconst msg = 'Hello!'\n\n// functions\nfunction log() {\n  console.log(msg)\n}\n</script>\n\n<template>\n  <button @click=\"log\">{{ msg }}</button>\n</template>\n```\n\nImports are exposed in the same fashion. This means you can directly use an imported helper function in template expressions without having to expose it via the `methods` option:\n\n```vue\n<script setup>\nimport { capitalize } from './helpers'\n</script>\n\n<template>\n  <div>{{ capitalize('hello') }}</div>\n</template>\n```\n\n## Reactivity \n\nReactive state needs to be explicitly created using [Reactivity APIs](./reactivity-core.html). Similar to values returned from a `setup()` function, refs are automatically unwrapped when referenced in templates:\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">{{ count }}</button>\n</template>\n```\n\n## Using Components \n\nValues in the scope of `<script setup>` can also be used directly as custom component tag names:\n\n```vue\n<script setup>\nimport MyComponent from './MyComponent.vue'\n</script>\n\n<template>\n  <MyComponent />\n</template>\n```\n\nThink of `MyComponent` as being referenced as a variable. If you have used JSX, the mental model is similar here. The kebab-case equivalent `<my-component>` also works in the template - however PascalCase component tags are strongly recommended for consistency. It also helps differentiating from native custom elements.\n\n### Dynamic Components \n\nSince components are referenced as variables instead of registered under string keys, we should use dynamic `:is` binding when using dynamic components inside `<script setup>`:\n\n```vue\n<script setup>\nimport Foo from './Foo.vue'\nimport Bar from './Bar.vue'\n</script>\n\n<template>\n  <component :is=\"Foo\" />\n  <component :is=\"someCondition ? Foo : Bar\" />\n</template>\n```\n\nNote how the components can be used as variables in a ternary expression.\n\n### Recursive Components \n\nAn SFC can implicitly refer to itself via its filename. E.g. a file named `FooBar.vue` can refer to itself as `<FooBar/>` in its template.\n\nNote this has lower priority than imported components. If you have a named import that conflicts with the component's inferred name, you can alias the import:\n\n```js\nimport { FooBar as FooBarChild } from './components'\n```\n\n### Namespaced Components \n\nYou can use component tags with dots like `<Foo.Bar>` to refer to components nested under object properties. This is useful when you import multiple components from a single file:\n\n```vue\n<script setup>\nimport * as Form from './form-components'\n</script>\n\n<template>\n  <Form.Input>\n    <Form.Label>label</Form.Label>\n  </Form.Input>\n</template>\n```\n\n## Using Custom Directives \n\nGlobally registered custom directives just work as normal. Local custom directives don't need to be explicitly registered with `<script setup>`, but they must follow the naming scheme `vNameOfDirective`:\n\n```vue\n<script setup>\nconst vMyDirective = {\n  beforeMount: (el) => {\n    // do something with the element\n  }\n}\n</script>\n<template>\n  <h1 v-my-directive>This is a Heading</h1>\n</template>\n```\n\nIf you're importing a directive from elsewhere, it can be renamed to fit the required naming scheme:\n\n```vue\n<script setup>\nimport { myDirective as vMyDirective } from './MyDirective.js'\n</script>\n```\n\n## defineProps() & defineEmits() \n\nTo declare options like `props` and `emits` with full type inference support, we can use the `defineProps` and `defineEmits` APIs, which are automatically available inside `<script setup>`:\n\n```vue\n<script setup>\nconst props = defineProps({\n  foo: String\n})\n\nconst emit = defineEmits(['change', 'delete'])\n// setup code\n</script>\n```\n\n- `defineProps` and `defineEmits` are **compiler macros** only usable inside `<script setup>`. They do not need to be imported, and are compiled away when `<script setup>` is processed.\n\n- `defineProps` accepts the same value as the `props` option, while `defineEmits` accepts the same value as the `emits` option.\n\n- `defineProps` and `defineEmits` provide proper type inference based on the options passed.\n\n- The options passed to `defineProps` and `defineEmits` will be hoisted out of setup into module scope. Therefore, the options cannot reference local variables declared in setup scope. Doing so will result in a compile error. However, it _can_ reference imported bindings since they are in the module scope as well.\n\nIf you are using TypeScript, it is also possible to [declare props and emits using pure type annotations](#typescript-only-features).\n\n## defineExpose() \n\nComponents using `<script setup>` are **closed by default** - i.e. the public instance of the component, which is retrieved via template refs or `$parent` chains, will **not** expose any of the bindings declared inside `<script setup>`.\n\nTo explicitly expose properties in a `<script setup>` component, use the `defineExpose` compiler macro:\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst a = 1\nconst b = ref(2)\n\ndefineExpose({\n  a,\n  b\n})\n</script>\n```\n\nWhen a parent gets an instance of this component via template refs, the retrieved instance will be of the shape `{ a: number, b: number }` (refs are automatically unwrapped just like on normal instances).\n\n## `useSlots()` & `useAttrs()` \n\nUsage of `slots` and `attrs` inside `<script setup>` should be relatively rare, since you can access them directly as `$slots` and `$attrs` in the template. In the rare case where you do need them, use the `useSlots` and `useAttrs` helpers respectively:\n\n```vue\n<script setup>\nimport { useSlots, useAttrs } from 'vue'\n\nconst slots = useSlots()\nconst attrs = useAttrs()\n</script>\n```\n\n`useSlots` and `useAttrs` are actual runtime functions that return the equivalent of `setupContext.slots` and `setupContext.attrs`. They can be used in normal composition API functions as well.\n\n## Usage alongside normal `<script>` \n\n`<script setup>` can be used alongside normal `<script>`. A normal `<script>` may be needed in cases where we need to:\n\n- Declare options that cannot be expressed in `<script setup>`, for example `inheritAttrs` or custom options enabled via plugins.\n- Declaring named exports.\n- Run side effects or create objects that should only execute once.\n\n```vue\n<script>\n// normal <script>, executed in module scope (only once)\nrunSideEffectOnce()\n\n// declare additional options\nexport default {\n  inheritAttrs: false,\n  customOptions: {}\n}\n</script>\n\n<script setup>\n// executed in setup() scope (for each instance)\n</script>\n```\n\nSupport for combining `<script setup>` and `<script>` in the same component is limited to the scenarios described above. Specifically:\n\n- Do **NOT** use a separate `<script>` section for options that can already be defined using `<script setup>`, such as `props` and `emits`.\n- Variables created inside `<script setup>` are not added as properties to the component instance, making them inaccessible from the Options API. Mixing APIs in this way is strongly discouraged.\n\nIf you find yourself in one of the scenarios that is not supported then you should consider switching to an explicit [`setup()`](https://vuejs.org/api/composition-api-setup.html) function, instead of using `<script setup>`.\n\n## Top-level `await` \n\nTop-level `await` can be used inside `<script setup>`. The resulting code will be compiled as `async setup()`:\n\n```vue\n<script setup>\nconst post = await fetch(`/api/post/1`).then((r) => r.json())\n</script>\n```\n\nIn addition, the awaited expression will be automatically compiled in a format that preserves the current component instance context after the `await`.\n\n:::warning Note\n`async setup()` must be used in combination with `Suspense`, which is currently still an experimental feature. We plan to finalize and document it in a future release - but if you are curious now, you can refer to its [tests](https://github.com/vuejs/core/blob/main/packages/runtime-core/__tests__/components/Suspense.spec.ts) to see how it works.\n:::\n\n## TypeScript-only Features <sup class=\"vt-badge ts\" /> \n\n### Type-only props/emit declarations \n\nProps and emits can also be declared using pure-type syntax by passing a literal type argument to `defineProps` or `defineEmits`:\n\n```ts\nconst props = defineProps<{\n  foo: string\n  bar?: number\n}>()\n\nconst emit = defineEmits<{\n  (e: 'change', id: number): void\n  (e: 'update', value: string): void\n}>()\n```\n\n- `defineProps` or `defineEmits` can only use either runtime declaration OR type declaration. Using both at the same time will result in a compile error.\n\n- When using type declaration, the equivalent runtime declaration is automatically generated from static analysis to remove the need for double declaration and still ensure correct runtime behavior.\n\n  - In dev mode, the compiler will try to infer corresponding runtime validation from the types. For example here `foo: String` is inferred from the `foo: string` type. If the type is a reference to an imported type, the inferred result will be `foo: null` (equal to `any` type) since the compiler does not have information of external files.\n\n  - In prod mode, the compiler will generate the array format declaration to reduce bundle size (the props here will be compiled into `['foo', 'bar']`)\n\n  - The emitted code is still TypeScript with valid typing, which can be further processed by other tools.\n\n- As of now, the type declaration argument must be one of the following to ensure correct static analysis:\n\n  - A type literal\n  - A reference to an interface or a type literal in the same file\n\n  Currently complex types and type imports from other files are not supported. It is possible to support type imports in the future.\n\n### Default props values when using type declaration \n\nOne drawback of the type-only `defineProps` declaration is that it doesn't have a way to provide default values for the props. To resolve this problem, a `withDefaults` compiler macro is also provided:\n\n```ts\nexport interface Props {\n  msg?: string\n  labels?: string[]\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  msg: 'hello',\n  labels: () => ['one', 'two']\n})\n```\n\nThis will be compiled to equivalent runtime props `default` options. In addition, the `withDefaults` helper provides type checks for the default values, and ensures the returned `props` type has the optional flags removed for properties that do have default values declared.\n\n## Restrictions \n\nDue to the difference in module execution semantics, code inside `<script setup>` relies on the context of an SFC. When moved into external `.js` or `.ts` files, it may lead to confusion for both developers and tools. Therefore, **`<script setup>`** cannot be used with the `src` attribute.\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-script-setup.html"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-script-setup.html"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-script-setup.html"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-script-setup.html"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-script-setup.html"
            }
          ]
        },
        {
          "name": "generic"
        }
      ],
      "description": {
        "kind": "markdown",
        "value": "\n- Each `*.vue` file can contain at most one `<script>` block at a time (excluding [`<script setup>`](https://vuejs.org/api/sfc-script-setup.html)).\n\n- The script is executed as an ES Module.\n\n- The **default export** should be a Vue component options object, either as a plain object or as the return value of [defineComponent](https://vuejs.org/api/general.html#definecomponent).\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#script"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#script"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#script"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#script"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#script"
        }
      ]
    },
    {
      "name": "script setup",
      "attributes": [
        {
          "name": "src",
          "description": {
            "kind": "markdown",
            "value": "\nIf you prefer splitting up your `*.vue` components into multiple files, you can use the `src` attribute to import an external file for a language block:\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\nBeware that `src` imports follow the same path resolution rules as webpack module requests, which means:\n\n- Relative paths need to start with `./`\n- You can import resources from npm dependencies:\n\n```vue\n<!-- import a file from the installed \"todomvc-app-css\" npm package -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` imports also work with custom blocks, e.g.:\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
            }
          ]
        }
      ],
      "description": {
        "kind": "markdown",
        "value": "\n- Each `*.vue` file can contain at most one `<script setup>` block at a time (excluding normal `<script>`).\n\n- The script is pre-processed and used as the component's `setup()` function, which means it will be executed **for each instance of the component**. Top-level bindings in `<script setup>` are automatically exposed to the template. For more details, see [dedicated documentation on `<script setup>`](https://vuejs.org/api/sfc-script-setup.html).\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#script-setup"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#script-setup"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#script-setup"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#script-setup"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#script-setup"
        }
      ]
    },
    {
      "name": "style",
      "attributes": [
        {
          "name": "src",
          "description": {
            "kind": "markdown",
            "value": "\nIf you prefer splitting up your `*.vue` components into multiple files, you can use the `src` attribute to import an external file for a language block:\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\nBeware that `src` imports follow the same path resolution rules as webpack module requests, which means:\n\n- Relative paths need to start with `./`\n- You can import resources from npm dependencies:\n\n```vue\n<!-- import a file from the installed \"todomvc-app-css\" npm package -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` imports also work with custom blocks, e.g.:\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
            }
          ]
        },
        {
          "name": "lang",
          "description": {
            "kind": "markdown",
            "value": "\nBlocks can declare pre-processor languages using the `lang` attribute. The most common case is using TypeScript for the `<script>` block:\n\n```html\n<script lang=\"ts\">\n  // use TypeScript\n</script>\n```\n\n`lang` can be applied to any block - for example we can use `<style>` with [Sass](https://sass-lang.com/) and `<template>` with [Pug](https://pugjs.org/api/getting-started.html):\n\n```html\n<template lang=\"pug\">\np {{ msg }}\n</template>\n\n<style lang=\"scss\">\n  $primary-color: #333;\n  body {\n    color: $primary-color;\n  }\n</style>\n```\n\nNote that integration with various pre-processors may differ by toolchain. Check out the respective documentation for examples:\n\n- [Vite](https://vitejs.dev/guide/features.html#css-pre-processors)\n- [Vue CLI](https://cli.vuejs.org/guide/css.html#pre-processors)\n- [webpack + vue-loader](https://vue-loader.vuejs.org/guide/pre-processors.html#using-pre-processors)\n"
          },
          "values": [
            {
              "name": "css"
            },
            {
              "name": "scss"
            },
            {
              "name": "less"
            },
            {
              "name": "stylus"
            },
            {
              "name": "postcss"
            },
            {
              "name": "sass"
            }
          ],
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#pre-processors"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#pre-processors"
            }
          ]
        },
        {
          "name": "scoped",
          "valueSet": "v",
          "description": {
            "kind": "markdown",
            "value": "\nWhen a `<style>` tag has the `scoped` attribute, its CSS will apply to elements of the current component only. This is similar to the style encapsulation found in Shadow DOM. It comes with some caveats, but doesn't require any polyfills. It is achieved by using PostCSS to transform the following:\n\n```vue\n<style scoped>\n.example {\n  color: red;\n}\n</style>\n\n<template>\n  <div class=\"example\">hi</div>\n</template>\n```\n\nInto the following:\n\n```vue\n<style>\n.example[data-v-f3f3eg9] {\n  color: red;\n}\n</style>\n\n<template>\n  <div class=\"example\" data-v-f3f3eg9>hi</div>\n</template>\n```\n\n### Child Component Root Elements \n\nWith `scoped`, the parent component's styles will not leak into child components. However, a child component's root node will be affected by both the parent's scoped CSS and the child's scoped CSS. This is by design so that the parent can style the child root element for layout purposes.\n\n### Deep Selectors \n\nIf you want a selector in `scoped` styles to be \"deep\", i.e. affecting child components, you can use the `:deep()` pseudo-class:\n\n```vue\n<style scoped>\n.a :deep(.b) {\n  /* ... */\n}\n</style>\n```\n\nThe above will be compiled into:\n\n```css\n.a[data-v-f3f3eg9] .b {\n  /* ... */\n}\n```\n\n:::tip\nDOM content created with `v-html` are not affected by scoped styles, but you can still style them using deep selectors.\n:::\n\n### Slotted Selectors \n\nBy default, scoped styles do not affect contents rendered by `<slot/>`, as they are considered to be owned by the parent component passing them in. To explicitly target slot content, use the `:slotted` pseudo-class:\n\n```vue\n<style scoped>\n:slotted(div) {\n  color: red;\n}\n</style>\n```\n\n### Global Selectors \n\nIf you want just one rule to apply globally, you can use the `:global` pseudo-class rather than creating another `<style>` (see below):\n\n```vue\n<style scoped>\n:global(.red) {\n  color: red;\n}\n</style>\n```\n\n### Mixing Local and Global Styles \n\nYou can also include both scoped and non-scoped styles in the same component:\n\n```vue\n<style>\n/* global styles */\n</style>\n\n<style scoped>\n/* local styles */\n</style>\n```\n\n### Scoped Style Tips \n\n- **Scoped styles do not eliminate the need for classes**. Due to the way browsers render various CSS selectors, `p { color: red }` will be many times slower when scoped (i.e. when combined with an attribute selector). If you use classes or ids instead, such as in `.example { color: red }`, then you virtually eliminate that performance hit.\n\n- **Be careful with descendant selectors in recursive components!** For a CSS rule with the selector `.a .b`, if the element that matches `.a` contains a recursive child component, then all `.b` in that child component will be matched by the rule.\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-css-features.html#scoped-css"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-css-features.html#scoped-css"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-css-features.html#scoped-css"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-css-features.html#scoped-css"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-css-features.html#scoped-css"
            }
          ]
        },
        {
          "name": "module",
          "valueSet": "v",
          "description": {
            "kind": "markdown",
            "value": "\nA `<style module>` tag is compiled as [CSS Modules](https://github.com/css-modules/css-modules) and exposes the resulting CSS classes to the component as an object under the key of `$style`:\n\n```vue\n<template>\n  <p :class=\"$style.red\">This should be red</p>\n</template>\n\n<style module>\n.red {\n  color: red;\n}\n</style>\n```\n\nThe resulting classes are hashed to avoid collision, achieving the same effect of scoping the CSS to the current component only.\n\nRefer to the [CSS Modules spec](https://github.com/css-modules/css-modules) for more details such as [global exceptions](https://github.com/css-modules/css-modules#exceptions) and [composition](https://github.com/css-modules/css-modules#composition).\n\n### Custom Inject Name \n\nYou can customize the property key of the injected classes object by giving the `module` attribute a value:\n\n```vue\n<template>\n  <p :class=\"classes.red\">red</p>\n</template>\n\n<style module=\"classes\">\n.red {\n  color: red;\n}\n</style>\n```\n\n### Usage with Composition API \n\nThe injected classes can be accessed in `setup()` and `<script setup>` via the `useCssModule` API. For `<style module>` blocks with custom injection names, `useCssModule` accepts the matching `module` attribute value as the first argument:\n\n```js\nimport { useCssModule } from 'vue'\n\n// inside setup() scope...\n// default, returns classes for <style module>\nuseCssModule()\n\n// named, returns classes for <style module=\"classes\">\nuseCssModule('classes')\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-css-features.html#css-modules"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-css-features.html#css-modules"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-css-features.html#css-modules"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-css-features.html#css-modules"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-css-features.html#css-modules"
            }
          ]
        }
      ],
      "description": {
        "kind": "markdown",
        "value": "\n- A single `*.vue` file can contain multiple `<style>` tags.\n\n- A `<style>` tag can have `scoped` or `module` attributes (see [SFC Style Features](https://vuejs.org/api/sfc-css-features.html) for more details) to help encapsulate the styles to the current component. Multiple `<style>` tags with different encapsulation modes can be mixed in the same component.\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#style"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#style"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#style"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#style"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#style"
        }
      ]
    },
    {
      "name": "Custom Blocks",
      "attributes": [
        {
          "name": "src",
          "description": {
            "kind": "markdown",
            "value": "\nIf you prefer splitting up your `*.vue` components into multiple files, you can use the `src` attribute to import an external file for a language block:\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\nBeware that `src` imports follow the same path resolution rules as webpack module requests, which means:\n\n- Relative paths need to start with `./`\n- You can import resources from npm dependencies:\n\n```vue\n<!-- import a file from the installed \"todomvc-app-css\" npm package -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` imports also work with custom blocks, e.g.:\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
          },
          "references": [
            {
              "name": "en",
              "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "zh-cn",
              "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ja",
              "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "ua",
              "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
            },
            {
              "name": "fr",
              "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
            }
          ]
        }
      ],
      "description": {
        "kind": "markdown",
        "value": "\nAdditional custom blocks can be included in a `*.vue` file for any project-specific needs, for example a `<docs>` block. Some real-world examples of custom blocks include:\n\n- [Gridsome: `<page-query>`](https://gridsome.org/docs/querying-data/)\n- [vite-plugin-vue-gql: `<gql>`](https://github.com/wheatjs/vite-plugin-vue-gql)\n- [vue-i18n: `<i18n>`](https://github.com/intlify/bundle-tools/tree/main/packages/vite-plugin-vue-i18n#i18n-custom-block)\n\nHandling of Custom Blocks will depend on tooling - if you want to build your own custom block integrations, see [relevant tooling section](https://vuejs.org/guide/scaling-up/tooling.html#sfc-custom-block-integrations) for more details.\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#custom-blocks"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#custom-blocks"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#custom-blocks"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#custom-blocks"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#custom-blocks"
        }
      ]
    }
  ],
  "globalAttributes": [
    {
      "name": "lang",
      "description": {
        "kind": "markdown",
        "value": "\nBlocks can declare pre-processor languages using the `lang` attribute. The most common case is using TypeScript for the `<script>` block:\n\n```html\n<script lang=\"ts\">\n  // use TypeScript\n</script>\n```\n\n`lang` can be applied to any block - for example we can use `<style>` with [Sass](https://sass-lang.com/) and `<template>` with [Pug](https://pugjs.org/api/getting-started.html):\n\n```html\n<template lang=\"pug\">\np {{ msg }}\n</template>\n\n<style lang=\"scss\">\n  $primary-color: #333;\n  body {\n    color: $primary-color;\n  }\n</style>\n```\n\nNote that integration with various pre-processors may differ by toolchain. Check out the respective documentation for examples:\n\n- [Vite](https://vitejs.dev/guide/features.html#css-pre-processors)\n- [Vue CLI](https://cli.vuejs.org/guide/css.html#pre-processors)\n- [webpack + vue-loader](https://vue-loader.vuejs.org/guide/pre-processors.html#using-pre-processors)\n"
      },
      "values": [],
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#pre-processors"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#pre-processors"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#pre-processors"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#pre-processors"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#pre-processors"
        }
      ]
    },
    {
      "name": "src",
      "description": {
        "kind": "markdown",
        "value": "\nIf you prefer splitting up your `*.vue` components into multiple files, you can use the `src` attribute to import an external file for a language block:\n\n```vue\n<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script src=\"./script.js\"></script>\n```\n\nBeware that `src` imports follow the same path resolution rules as webpack module requests, which means:\n\n- Relative paths need to start with `./`\n- You can import resources from npm dependencies:\n\n```vue\n<!-- import a file from the installed \"todomvc-app-css\" npm package -->\n<style src=\"todomvc-app-css/index.css\" />\n```\n\n`src` imports also work with custom blocks, e.g.:\n\n```vue\n<unit-test src=\"./unit-test.js\">\n</unit-test>\n```\n"
      },
      "references": [
        {
          "name": "en",
          "url": "https://vuejs.org/api/sfc-spec.html#src-imports"
        },
        {
          "name": "zh-cn",
          "url": "https://cn.vuejs.org/api/sfc-spec.html#src-imports"
        },
        {
          "name": "ja",
          "url": "https://ja.vuejs.org/api/sfc-spec.html#src-imports"
        },
        {
          "name": "ua",
          "url": "https://ua.vuejs.org/api/sfc-spec.html#src-imports"
        },
        {
          "name": "fr",
          "url": "https://fr.vuejs.org/api/sfc-spec.html#src-imports"
        }
      ]
    }
  ]
}